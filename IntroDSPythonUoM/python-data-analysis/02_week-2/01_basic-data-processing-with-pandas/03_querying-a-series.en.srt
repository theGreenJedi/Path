1
00:00:08,923 --> 00:00:13,090
A panda.Series can be queried, either by
the index position or the index label.

2
00:00:13,090 --> 00:00:15,930
As we saw, if you don't give an index
to the series, the position and

3
00:00:15,930 --> 00:00:18,500
the label are effectively the same values.

4
00:00:18,500 --> 00:00:23,580
To query by numeric location,
starting at zero, use the iloc attribute.

5
00:00:23,580 --> 00:00:27,270
To query by the index label,
you can use the loc attribute.

6
00:00:27,270 --> 00:00:31,320
Here's an example using national
sporting event data from Wikipedia.

7
00:00:31,320 --> 00:00:34,240
Let's say we want to have a list of
all of the sports in our index and

8
00:00:34,240 --> 00:00:36,190
a list of countries as values.

9
00:00:36,190 --> 00:00:39,630
You might keep these in a dictionary and
create a series as we discussed.

10
00:00:40,660 --> 00:00:43,140
If you wanted to see
the fourth country on this,

11
00:00:43,140 --> 00:00:47,180
we would use the iloc attribute
with the parameter 3.

12
00:00:47,180 --> 00:00:50,540
If you wanted to see which country
has golf as its national sport,

13
00:00:50,540 --> 00:00:53,630
we would use the loc attribute
with parameter golf.

14
00:00:53,630 --> 00:00:57,060
Keep in mind that iloc and
loc are not methods, they are attributes.

15
00:00:57,060 --> 00:01:00,629
So you don't use parentheses to query
them, but square brackets instead,

16
00:01:00,629 --> 00:01:02,850
which we'll call the indexing operator.

17
00:01:02,850 --> 00:01:03,550
Though in Python,

18
00:01:03,550 --> 00:01:06,840
this calls get and set an item methods
depending on the context of its use.

19
00:01:07,970 --> 00:01:11,750
This might seem a bit confusing if you're
used to languages where encapsulation of

20
00:01:11,750 --> 00:01:15,220
attributes, variables, and
properties is common, such as in Java.

21
00:01:15,220 --> 00:01:19,510
Pandas tries to make our code a bit
more readable and provides a sort of

22
00:01:19,510 --> 00:01:24,900
smart syntax using the indexing
operator directly on the series itself.

23
00:01:24,900 --> 00:01:27,600
For instance,
if you pass in an integer parameter,

24
00:01:27,600 --> 00:01:32,390
the operator will behave as if you want
it to query via the iloc attribute.

25
00:01:32,390 --> 00:01:33,640
If you pass in an object,

26
00:01:33,640 --> 00:01:37,220
it will query as if you wanted to
use the label based loc attribute.

27
00:01:38,400 --> 00:01:42,080
So what happens if your
index is a list of integers?

28
00:01:42,080 --> 00:01:44,630
This is a bit complicated,
and Pandas can't determine

29
00:01:44,630 --> 00:01:49,470
automatically whether you're intending to
query by index position or index label.

30
00:01:49,470 --> 00:01:53,140
So you need to be careful when using the
indexing operator on the series itself.

31
00:01:53,140 --> 00:01:57,430
And the safer option is to be
more explicit and use the iloc or

32
00:01:57,430 --> 00:01:58,870
loc attributes directly.

33
00:02:00,380 --> 00:02:02,980
Here's an example using
some new sports data,

34
00:02:02,980 --> 00:02:05,255
where countries are indexed by integer.

35
00:02:05,255 --> 00:02:07,864
If we try and call s sub zero,
we get a key error,

36
00:02:07,864 --> 00:02:12,080
because there's no item in the sports
list with an index of zero.

37
00:02:12,080 --> 00:02:15,910
Instead we have to call iloc
explicitly if we want the first item.

38
00:02:18,040 --> 00:02:20,690
Okay, so now we know how to
get data out of the series.

39
00:02:20,690 --> 00:02:23,150
Let's talk about working with the data.

40
00:02:23,150 --> 00:02:26,361
A common task is to want to consider all
of the values inside of a series and

41
00:02:26,361 --> 00:02:28,650
want to do some sort of operation.

42
00:02:28,650 --> 00:02:31,620
This could be trying to find
a certain number, summarizing data or

43
00:02:31,620 --> 00:02:33,290
transforming the data in some way.

44
00:02:34,330 --> 00:02:37,700
A typical programmatic approach
to this would be to iterate over

45
00:02:37,700 --> 00:02:42,380
all the items in the series, and
invoke the operation one is interested in.

46
00:02:42,380 --> 00:02:46,040
For instance, we could create a data
frame of floating point values.

47
00:02:46,040 --> 00:02:49,130
Let's think of these as prices for
different products.

48
00:02:49,130 --> 00:02:52,060
We could write a little routine which
iterates over all of the items in

49
00:02:52,060 --> 00:02:54,309
the series and
adds them together to get a total.

50
00:02:55,320 --> 00:02:57,310
This works, but it's slow.

51
00:02:57,310 --> 00:03:01,200
Modern computers can do many tasks
simultaneously, especially, but

52
00:03:01,200 --> 00:03:03,460
not only, tasks involving mathematics.

53
00:03:04,460 --> 00:03:08,447
Pandas and the underlying NumPy libraries
support a method of computation called

54
00:03:08,447 --> 00:03:09,320
vectorization.

55
00:03:10,540 --> 00:03:14,100
Vectorization works with most of
the functions in the NumPy library,

56
00:03:14,100 --> 00:03:15,380
including the sum function.

57
00:03:16,560 --> 00:03:19,990
Here's how we would really write
the code using the NumPy sum method.

58
00:03:19,990 --> 00:03:24,423
First we need to import the numpy module,
and then we just call np.sum and

59
00:03:24,423 --> 00:03:26,035
pass in an iterable item.

60
00:03:26,035 --> 00:03:27,750
In this case, our panda series.

61
00:03:29,210 --> 00:03:33,640
Now both of these methods create the same
value, but is one actually faster?

62
00:03:33,640 --> 00:03:36,920
The Jupyter Notebook has a magic
function which can help.

63
00:03:36,920 --> 00:03:39,750
First, let's create a big
series of random numbers.

64
00:03:39,750 --> 00:03:43,700
You'll see this used a lot when
demonstrating techniques with Pandas.

65
00:03:43,700 --> 00:03:46,590
Note that I've just used the head method,
which reduces the amount of

66
00:03:46,590 --> 00:03:50,540
data printed out by the series
to the first five elements.

67
00:03:50,540 --> 00:03:54,920
We can actually verify that length of the
series is correct using the len function.

68
00:03:54,920 --> 00:03:57,322
Magic functions begin
with a percentage sign.

69
00:03:57,322 --> 00:03:59,530
If we type this sign and
then hit the Tab key,

70
00:03:59,530 --> 00:04:02,580
we can see a list of
the available magic functions.

71
00:04:02,580 --> 00:04:04,433
You could write your own
magic functions too, but

72
00:04:04,433 --> 00:04:07,450
that's a little bit outside
of the scope of this course.

73
00:04:07,450 --> 00:04:10,725
We're actually going to use what's
called a cellular magic function.

74
00:04:10,725 --> 00:04:12,530
These start with two percentage signs and

75
00:04:12,530 --> 00:04:15,860
modify a raptor code in
the current Jupyter cell.

76
00:04:15,860 --> 00:04:18,440
The function we're going
to use is called timeit.

77
00:04:18,440 --> 00:04:21,740
And as you may have guessed from the name,
this function will run our code a few

78
00:04:21,740 --> 00:04:24,270
times to determine,
on average, how long it takes.

79
00:04:25,300 --> 00:04:27,880
Let's run timeit with our
original iterative code.

80
00:04:27,880 --> 00:04:31,050
You can give timeit the number of
loops that you would like to run.

81
00:04:31,050 --> 00:04:33,395
By default, we'll use 1,000 loops.

82
00:04:33,395 --> 00:04:36,840
I'll ask timeit here to use 100
runs because we're recording this.

83
00:04:37,980 --> 00:04:38,762
Not bad.

84
00:04:38,762 --> 00:04:42,310
Timeit ran this code and it doesn't
seem like it takes very long at all.

85
00:04:42,310 --> 00:04:43,940
Now let's try with vectorization.

86
00:04:45,230 --> 00:04:45,880
Wow!

87
00:04:45,880 --> 00:04:48,190
This is a pretty shocking
difference in the speed and

88
00:04:48,190 --> 00:04:52,670
demonstrates why data scientists need to
be aware of parallel computing features

89
00:04:52,670 --> 00:04:54,850
and start thinking in
functional programming terms.

90
00:04:56,140 --> 00:04:59,660
Related feature in Pandas and
NumPy is called broadcasting.

91
00:04:59,660 --> 00:05:03,220
With broadcasting, you can apply
an operation to every value in the series,

92
00:05:03,220 --> 00:05:04,080
changing the series.

93
00:05:05,080 --> 00:05:08,920
For instance, if we wanted to
increase every random variable by 2,

94
00:05:08,920 --> 00:05:14,460
we could do so quickly using the +=
operator directly on the series object.

95
00:05:14,460 --> 00:05:17,870
Here I'll just use the head operator
to just print out the top five rows in

96
00:05:17,870 --> 00:05:18,389
the series.

97
00:05:19,910 --> 00:05:22,650
The procedural way of doing this
would be to iterate through all of

98
00:05:22,650 --> 00:05:26,220
the items in the series and
increase the values directly.

99
00:05:26,220 --> 00:05:27,605
A quick aside here.

100
00:05:27,605 --> 00:05:30,870
Pandas does support iterating through
a series much like a dictionary,

101
00:05:30,870 --> 00:05:33,310
allowing you to unpack values easily.

102
00:05:33,310 --> 00:05:35,660
But if you find yourself
iterating through a series,

103
00:05:35,660 --> 00:05:38,980
you should question whether you're
doing things in the best possible way.

104
00:05:40,200 --> 00:05:43,330
Here's how we would do this using
the series set value method.

105
00:05:44,490 --> 00:05:46,656
Let's try and time the two approaches.

106
00:06:00,959 --> 00:06:02,165
Amazing.

107
00:06:02,165 --> 00:06:05,415
Not only is it significantly faster,
but it's more concise and

108
00:06:05,415 --> 00:06:07,785
maybe even easier to read too.

109
00:06:07,785 --> 00:06:12,476
The typical mathematical operations you
would expect are vectorized, and the NumPy

110
00:06:12,476 --> 00:06:17,053
documentation outlines what it takes to
create vectorized functions of your own.

111
00:06:17,053 --> 00:06:21,710
One last note on using the indexing
operators to access series data.

112
00:06:21,710 --> 00:06:25,234
The .loc attribute lets you not
only modify data in place, but

113
00:06:25,234 --> 00:06:26,707
also add new data as well.

114
00:06:26,707 --> 00:06:31,710
If the value you pass in as the index
doesn't exist, then a new entry is added.

115
00:06:31,710 --> 00:06:34,050
And keep in mind,
indices can have mixed types.

116
00:06:34,050 --> 00:06:37,550
While it's important to be aware
of the typing going on underneath,

117
00:06:37,550 --> 00:06:41,430
Pandas will automatically change
the underlying NumPy types as appropriate.

118
00:06:42,560 --> 00:06:45,840
Here's an example using
a series of a few numbers.

119
00:06:45,840 --> 00:06:49,610
We could add some new value, maybe
an animal, as you know, I like bears.

120
00:06:49,610 --> 00:06:52,610
Just by calling the .loc
indexing operator.

121
00:06:52,610 --> 00:06:57,500
We see that mixed types for data values or
index labels are no problem for Pandas.

122
00:06:59,540 --> 00:07:04,320
Up until now I've shown only examples of a
series where the index values were unique.

123
00:07:04,320 --> 00:07:07,390
I want to end this lecture by showing an
example where index values are not unique,

124
00:07:07,390 --> 00:07:09,860
and this makes data frames different,

125
00:07:09,860 --> 00:07:12,210
conceptually, that a relational
database might be.

126
00:07:13,450 --> 00:07:16,320
Revisiting the issue of countries and
their national sports,

127
00:07:16,320 --> 00:07:19,690
it turns out that many countries
seem to like this game cricket.

128
00:07:19,690 --> 00:07:21,760
We go back to our original
series on sports.

129
00:07:21,760 --> 00:07:25,310
It's possible to create a new series
object with multiple entries for

130
00:07:25,310 --> 00:07:29,130
cricket, and
then use append to bring these together.

131
00:07:29,130 --> 00:07:32,380
There are a couple of important
considerations when using append.

132
00:07:32,380 --> 00:07:34,410
First, Pandas is going
to take your series and

133
00:07:34,410 --> 00:07:37,000
try to infer the best data types to use.

134
00:07:37,000 --> 00:07:39,840
In this example, everything is a string,
so there's no problems here.

135
00:07:41,140 --> 00:07:45,050
Second, the append method doesn't
actually change the underlying series.

136
00:07:45,050 --> 00:07:50,100
It instead returns a new series which is
made up of the two appended together.

137
00:07:50,100 --> 00:07:53,730
We can see this by going back and
printing the original series of values and

138
00:07:53,730 --> 00:07:55,190
seeing that they haven't changed.

139
00:07:56,230 --> 00:07:58,360
This is actually a significant issue for

140
00:07:58,360 --> 00:08:03,240
new Pandas users who are used to
objects being changed in place.

141
00:08:03,240 --> 00:08:07,400
So watch out for it, not just with append
but with other Pandas functions as well.

142
00:08:08,970 --> 00:08:12,580
Finally, we see that when we query the
appended series for those who have cricket

143
00:08:12,580 --> 00:08:17,520
as their national sport, we don't get
a single value, but a series itself.

144
00:08:17,520 --> 00:08:19,330
This is actually very common, and

145
00:08:19,330 --> 00:08:22,930
if you have a relational database
background, this is very similar to

146
00:08:22,930 --> 00:08:27,020
every table query resulting in
a return set which itself is a table.

147
00:08:28,110 --> 00:08:28,810
In this lecture,

148
00:08:28,810 --> 00:08:33,730
we focused on one of the primary data
types of the Pandas library, the series.

149
00:08:33,730 --> 00:08:36,630
There are many more methods associated
with this series object that we haven't

150
00:08:36,630 --> 00:08:37,250
talked about.

151
00:08:37,250 --> 00:08:39,838
But with these basics down,
we'll move on to talking about

152
00:08:39,838 --> 00:08:43,510
the Panda's two-dimensional
data structure, the data frame.

153
00:08:43,510 --> 00:08:46,230
The data frame is very similar
to the series object, but

154
00:08:46,230 --> 00:08:49,620
includes multiple columns of data,
and is the structure that you'll spend

155
00:08:49,620 --> 00:08:53,000
the majority of your time working with
when cleaning and aggregating data.

156
00:08:54,560 --> 00:08:58,460
But before we move on to a discussion of
the data frame, our tutorial assistant for

157
00:08:58,460 --> 00:09:02,870
this course will provide a more in-depth
look at how the series object can be used.