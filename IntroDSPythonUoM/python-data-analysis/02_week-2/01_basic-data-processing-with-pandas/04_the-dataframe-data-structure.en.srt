1
00:00:08,779 --> 00:00:12,230
The DataFrame data structure is
the heart of the Panda's library.

2
00:00:12,230 --> 00:00:15,450
It's a primary object that you'll
be working with in data analysis

3
00:00:15,450 --> 00:00:16,110
and cleaning tasks.

4
00:00:17,380 --> 00:00:20,916
The DataFrame is conceptually
a two-dimensional series object, where

5
00:00:20,916 --> 00:00:25,890
there's an index and multiple columns of
content, with each column having a label.

6
00:00:25,890 --> 00:00:28,293
In fact,
the distinction between a column and

7
00:00:28,293 --> 00:00:30,766
a row is really only
a conceptual distinction.

8
00:00:30,766 --> 00:00:34,951
And you can think of the DataFrame itself
as simply a two-axes labeled array.

9
00:00:36,550 --> 00:00:38,630
You can create a DataFrame
in many different ways,

10
00:00:38,630 --> 00:00:40,610
some of which you might expect.

11
00:00:40,610 --> 00:00:42,890
For instance,
you can use a group of series,

12
00:00:42,890 --> 00:00:45,119
where each series
represents a row of data.

13
00:00:45,119 --> 00:00:46,957
Or you could use a group of dictionaries,

14
00:00:46,957 --> 00:00:49,120
where each dictionary
represents a row of data.

15
00:00:50,370 --> 00:00:52,400
Let's take a look at an example.

16
00:00:52,400 --> 00:00:55,650
I'm going to create three purchase
order records as series objects for

17
00:00:55,650 --> 00:00:57,860
a sort of fictional store.

18
00:00:57,860 --> 00:00:59,860
Each series has a name of a customer,

19
00:00:59,860 --> 00:01:04,430
the string which describes the item being
purchased, and the cost of the items.

20
00:01:04,430 --> 00:01:07,150
I like dogs, so
I'll purchase a bunch of dog food.

21
00:01:07,150 --> 00:01:10,510
Kevin Cullens Thompson, the instructor for
the third course in the series,

22
00:01:10,510 --> 00:01:14,630
he seems more like a cat man to me, so
I'll have him purchase some kitty litter.

23
00:01:14,630 --> 00:01:17,600
And I think Vinod, who teaches
the fourth course in this series,

24
00:01:17,600 --> 00:01:20,210
is more of a bird man, so
I'll add some bird seed there.

25
00:01:21,780 --> 00:01:25,283
Then we'll feed this into the DataFrame
as the first argument and

26
00:01:25,283 --> 00:01:29,112
set index values indicating which
store where each purchase was done.

27
00:01:29,112 --> 00:01:32,448
You'll see that when we print out
a DataFrame, the Jupiter notebook's trying

28
00:01:32,448 --> 00:01:35,160
to pretty it up a bit, and
print it out as a table, which is nice.

29
00:01:36,720 --> 00:01:41,370
Similar to the series, we can extract
data using the iLock and Lock attributes.

30
00:01:41,370 --> 00:01:44,850
Because the DataFrame is two-dimensional,
passing a single value to the lock

31
00:01:44,850 --> 00:01:48,830
indexing operator will return series
if there's only one row to return.

32
00:01:50,370 --> 00:01:53,300
In this example, if we wanted to
select data associated with Store 2,

33
00:01:53,300 --> 00:01:56,110
we would just query the lock
attribute with one parameter.

34
00:01:57,460 --> 00:02:01,090
You'll note that the name of the series
is returned as the row index value,

35
00:02:01,090 --> 00:02:03,440
while the column name is
included in the output as well.

36
00:02:04,630 --> 00:02:09,517
We can check the data type of the return
using the python type function.

37
00:02:09,517 --> 00:02:12,636
It's important to remember
that the indices and

38
00:02:12,636 --> 00:02:17,980
column names along either axes, horizontal
or vertical, could be non-unique.

39
00:02:17,980 --> 00:02:21,240
For instance, in this example,
we see two purchase records for

40
00:02:21,240 --> 00:02:23,770
Store 1 as different rows.

41
00:02:23,770 --> 00:02:27,470
If we use a single value with the
DataFrame lock attribute, multiple rows of

42
00:02:27,470 --> 00:02:31,110
the DataFrame will return, not as
a new series, but as a new DataFrame.

43
00:02:32,710 --> 00:02:35,729
For instance, if we query for
Store 1 records,

44
00:02:35,729 --> 00:02:39,868
we see that Chris and Kevin both
shop at the same pets supply store.

45
00:02:39,868 --> 00:02:43,737
One of the powers of the Panda's DataFrame
is that you can quickly select data based

46
00:02:43,737 --> 00:02:45,370
on multiple axes.

47
00:02:45,370 --> 00:02:49,534
For instance, if you wanted to just list
the costs for Store 1, you would supply

48
00:02:49,534 --> 00:02:53,961
two parameters to .log, one being the row
index and the other being the column name.

49
00:02:53,961 --> 00:02:58,920
If we're only interested in Store 1 costs,
we could write this as df.lock('Store 1',

50
00:02:58,920 --> 00:02:59,690
'Cost').

51
00:03:01,260 --> 00:03:03,790
What if we just wanted to
do column selection and

52
00:03:03,790 --> 00:03:06,170
just get a list of all of the costs?

53
00:03:06,170 --> 00:03:07,870
Well, there's a couple of options.

54
00:03:07,870 --> 00:03:10,142
First, you can get
a transpose of the DataFrame,

55
00:03:10,142 --> 00:03:14,260
using the capital T attribute,
which swaps all of the columns and rows.

56
00:03:14,260 --> 00:03:16,925
This essentially turns your
column names into indices.

57
00:03:16,925 --> 00:03:19,790
And we can then use the .lock method.

58
00:03:19,790 --> 00:03:21,280
This works, but it's pretty ugly.

59
00:03:22,640 --> 00:03:26,270
Since iloc and loc are used for
row selection, the Panda's developers

60
00:03:26,270 --> 00:03:30,226
reserved indexing operator directly on
the DataFrame for column selection.

61
00:03:30,226 --> 00:03:33,779
In a Panda's DataFrame,
columns always have a name.

62
00:03:33,779 --> 00:03:37,568
So this selection is always label based,
not as confusing as it was when

63
00:03:37,568 --> 00:03:41,460
using the square bracket
operator on the series objects.

64
00:03:41,460 --> 00:03:43,770
For those familiar with
relational databases,

65
00:03:43,770 --> 00:03:46,340
this operator is analogous
to column projection.

66
00:03:48,090 --> 00:03:51,200
Finally, since the result of
using the indexing operators,

67
00:03:51,200 --> 00:03:55,180
the DataFrame or series,
you can chain operations together.

68
00:03:55,180 --> 00:03:58,243
For instance,
we could have rewritten the query for

69
00:03:58,243 --> 00:04:01,800
all Store 1 costs as df.loc('Store 1',
'Cost').

70
00:04:02,850 --> 00:04:06,280
This looks pretty reasonable and
gets us the result we wanted.

71
00:04:06,280 --> 00:04:08,431
But chaining can come with some costs and

72
00:04:08,431 --> 00:04:11,030
is best avoided if you
can use another approach.

73
00:04:11,030 --> 00:04:15,705
In particular, chaining tends to cause
Pandas to return a copy of the DataFrame

74
00:04:15,705 --> 00:04:17,840
instead of a view on the DataFrame.

75
00:04:17,840 --> 00:04:18,880
For selecting a data,

76
00:04:18,880 --> 00:04:22,590
this is not a big deal,
though it might be slower than necessary.

77
00:04:22,590 --> 00:04:25,510
If you are changing data though,
this is an important distinction and

78
00:04:25,510 --> 00:04:26,559
can be a source of error.

79
00:04:27,810 --> 00:04:29,370
Here's another method.

80
00:04:29,370 --> 00:04:32,810
As we saw, .loc does row selection,
and it can take two parameters,

81
00:04:32,810 --> 00:04:35,490
the row index and
the list of column names.

82
00:04:35,490 --> 00:04:38,130
.loc also supports slicing.

83
00:04:38,130 --> 00:04:39,634
If we wanted to select all rows,

84
00:04:39,634 --> 00:04:42,721
we can use a column to indicate
a full slice from beginning to end.

85
00:04:42,721 --> 00:04:47,150
And then add the column name as
the second parameter as a string.

86
00:04:47,150 --> 00:04:50,620
In fact, if we wanted to include multiply
columns, we could do so in a list.

87
00:04:50,620 --> 00:04:53,330
And Pandas will bring back only
the columns we have asked for.

88
00:04:54,750 --> 00:04:56,190
Here's an example, where we ask for

89
00:04:56,190 --> 00:05:00,370
all of the name and cost values for
all stores using the .loc operator.

90
00:05:02,010 --> 00:05:05,290
So that's selecting and projecting
data from a DataFrame based on row and

91
00:05:05,290 --> 00:05:06,580
column labels.

92
00:05:06,580 --> 00:05:10,120
The key concepts to remember are that
the rows and columns are really just for

93
00:05:10,120 --> 00:05:11,120
our benefit.

94
00:05:11,120 --> 00:05:14,220
Underneath this is just a two
axes labeled array, and

95
00:05:14,220 --> 00:05:15,800
transposing the columns is easy.

96
00:05:16,830 --> 00:05:19,610
Also, consider the issue
of chaining carefully, and

97
00:05:19,610 --> 00:05:22,740
try to avoid it,
it can cause unpredictable results.

98
00:05:22,740 --> 00:05:25,140
Where your intent was to
obtain a view of the data, but

99
00:05:25,140 --> 00:05:27,044
instead Pandas returns to you a copy.

100
00:05:27,044 --> 00:05:30,810
In the Panda's world,
friends don't let friends chain calls.

101
00:05:30,810 --> 00:05:33,710
So if you see it, point it out, and
share a less ambiguous solution.

102
00:05:34,870 --> 00:05:38,520
Now, before we leave the discussion
of accessing data in DataFrames,

103
00:05:38,520 --> 00:05:40,060
let's talk about dropping data.

104
00:05:41,680 --> 00:05:44,610
It's easy to delete data in series and
DataFrames, and

105
00:05:44,610 --> 00:05:47,090
we can use the drop function to do so.

106
00:05:47,090 --> 00:05:52,121
This function takes a single parameter,
which is the index or roll label, to drop.

107
00:05:52,121 --> 00:05:55,400
This is another tricky place for
new users to pad this.

108
00:05:55,400 --> 00:05:58,480
The drop function doesn't change
the DataFrame by default.

109
00:05:58,480 --> 00:06:03,270
And instead, returns to you a copy of
the DataFrame with the given rows removed.

110
00:06:03,270 --> 00:06:07,030
We can see that our original
DataFrame is still intact.

111
00:06:07,030 --> 00:06:10,960
Let's make a copy with the copy method and
do a drop on it instead.

112
00:06:10,960 --> 00:06:15,360
This is a very typical pattern in Pandas,
where in place changes to a DataFrame

113
00:06:15,360 --> 00:06:19,360
are only done if need be,
usually on changes involving indices.

114
00:06:19,360 --> 00:06:20,700
So it's important to be aware of.

115
00:06:21,950 --> 00:06:24,460
Drop has two interesting
optional parameters.

116
00:06:24,460 --> 00:06:27,240
The first is called in place,
and if it's set to true,

117
00:06:27,240 --> 00:06:31,460
the DataFrame will be updated in place,
instead of a copy being returned.

118
00:06:31,460 --> 00:06:34,680
The second parameter is the axes,
which should be dropped.

119
00:06:34,680 --> 00:06:37,997
By default, this value is 0,
indicating the row axes.

120
00:06:37,997 --> 00:06:40,310
But you could change it to 1
if you want to drop a column.

121
00:06:42,210 --> 00:06:44,670
There is a second way to drop a column,
however.

122
00:06:44,670 --> 00:06:49,360
And that's directly through the use of the
indexing operator, using the del keyword.

123
00:06:50,940 --> 00:06:52,050
This way of dropping data,

124
00:06:52,050 --> 00:06:55,650
however, takes immediate effect on
the DataFrame and does not return a view.

125
00:06:56,870 --> 00:06:59,750
Finally, adding a new
column to the DataFrame is

126
00:06:59,750 --> 00:07:02,270
as easy as assigning it to some value.

127
00:07:02,270 --> 00:07:02,930
For instance,

128
00:07:02,930 --> 00:07:06,850
if we wanted to add a new location as
a column with default value of none,

129
00:07:06,850 --> 00:07:11,270
we could do so by using the assignment
operator after the square brackets.

130
00:07:11,270 --> 00:07:15,274
This broadcasts the default value
to the new column immediately.