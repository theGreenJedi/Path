1
00:00:08,790 --> 00:00:11,109
Before we talk about how
to query data frames,

2
00:00:11,109 --> 00:00:13,900
we need to talk about Boolean masking.

3
00:00:13,900 --> 00:00:17,920
Boolean masking is the heart of fast and
efficient querying in NumPy.

4
00:00:17,920 --> 00:00:21,089
It's analogous a bit to masking
used in other computational areas.

5
00:00:22,660 --> 00:00:26,420
A Boolean mask is an array which can
be of one dimension like a series, or

6
00:00:26,420 --> 00:00:28,380
two dimensions like a data frame,

7
00:00:28,380 --> 00:00:32,280
where each of the values in
the array are either true or false.

8
00:00:32,280 --> 00:00:36,680
This array is essentially overlaid on top
of the data structure that we're querying.

9
00:00:36,680 --> 00:00:40,800
And any cell aligned with the true value
will be admitted into our final result,

10
00:00:40,800 --> 00:00:43,020
and any sign aligned with
a false value will not.

11
00:00:44,350 --> 00:00:46,780
Boolean masking is
powerful conceptually and

12
00:00:46,780 --> 00:00:50,800
is the cornerstone of efficient NumPy and
pandas querying.

13
00:00:50,800 --> 00:00:54,470
This technique is well used in other
areas of computer science, for instance,

14
00:00:54,470 --> 00:00:55,590
in graphics.

15
00:00:55,590 --> 00:00:59,940
But it doesn't really have an analogue in
other traditional relational databases, so

16
00:00:59,940 --> 00:01:02,410
I think it's worth pointing out here.

17
00:01:02,410 --> 00:01:06,700
Boolean masks are created by applying
operators directly to the pandas series or

18
00:01:06,700 --> 00:01:08,770
DataFrame objects.

19
00:01:08,770 --> 00:01:12,720
For instance, in our Olympics data set,
you might be interested in seeing only

20
00:01:12,720 --> 00:01:16,660
those countries who have achieved
a gold medal at the summer Olympics.

21
00:01:16,660 --> 00:01:21,280
To build a Boolean mask for this query, we
project the gold column using the indexing

22
00:01:21,280 --> 00:01:26,670
operator and apply the greater than
operator with a comparison value of zero.

23
00:01:26,670 --> 00:01:29,900
This is essentially broadcasting
a comparison operator,

24
00:01:29,900 --> 00:01:33,770
greater than, with the results
being returned as a Boolean series.

25
00:01:33,770 --> 00:01:37,480
The resultant series is indexed where
the value of each cell is either true or

26
00:01:37,480 --> 00:01:41,690
false depending on whether a country
has won at least one gold medal, and

27
00:01:41,690 --> 00:01:42,890
the index is the country name.

28
00:01:43,920 --> 00:01:47,380
So this builds us the Boolean mask,
which is half the battle.

29
00:01:47,380 --> 00:01:50,790
What we want to do next is overlay
that mask on the data frame.

30
00:01:50,790 --> 00:01:53,310
We can do this using the where function.

31
00:01:53,310 --> 00:01:57,230
The where function takes a Boolean mask as
a condition, applies it to the data frame

32
00:01:57,230 --> 00:02:01,830
or series, and returns a new data frame or
series of the same shape.

33
00:02:01,830 --> 00:02:05,520
Let's apply this Boolean mask to our
Olympics data and create a data frame of

34
00:02:05,520 --> 00:02:08,580
only those countries who have
won a gold at a summer games.

35
00:02:09,650 --> 00:02:13,990
We see that the resulting data frame
keeps the original indexed values, and

36
00:02:13,990 --> 00:02:17,750
only data from countries that
met the condition are retained.

37
00:02:17,750 --> 00:02:22,540
All of the countries which did not meet
the condition have NaN data instead.

38
00:02:22,540 --> 00:02:23,440
This is okay.

39
00:02:23,440 --> 00:02:28,000
Most statistical functions built into the
data frame object ignore values of NaN.

40
00:02:29,330 --> 00:02:33,580
For instance, if we call the df.count
on the only gold data frame,

41
00:02:33,580 --> 00:02:37,290
we see that there are 100 countries which
have had gold medals awarded at the summer

42
00:02:37,290 --> 00:02:40,840
games, while if we call count
on the original data frame,

43
00:02:40,840 --> 00:02:43,550
we see that there are 147 countries total.

44
00:02:44,950 --> 00:02:48,630
Often we want to drop those
rows which have no data.

45
00:02:48,630 --> 00:02:51,600
To do this,
we can use the drop NA function.

46
00:02:51,600 --> 00:02:55,230
You can optionally provide drop NA
the axes it should be considering.

47
00:02:55,230 --> 00:02:59,020
Remember that the axes is just
an indicator for the columns or rows and

48
00:02:59,020 --> 00:03:01,130
that the default is zero,
which means rows.

49
00:03:02,410 --> 00:03:05,770
When you find yourself talking about
pandas and saying phrases like,

50
00:03:05,770 --> 00:03:10,120
often I want to, it's quite likely the
developers have included a shortcut for

51
00:03:10,120 --> 00:03:11,830
this common operation.

52
00:03:11,830 --> 00:03:13,552
For instance, in this example,

53
00:03:13,552 --> 00:03:16,820
we don't actually have to use
the where function explicitly.

54
00:03:16,820 --> 00:03:20,246
The pandas developers allow
the indexing operator to

55
00:03:20,246 --> 00:03:24,594
take a Boolean mask as a value instead
of just a list of column names.

56
00:03:24,594 --> 00:03:27,988
The syntax might look a little messy,
especially if you're not used

57
00:03:27,988 --> 00:03:30,916
to programming languages with
overloaded operators, but

58
00:03:30,916 --> 00:03:35,150
the result is that you're able to filter
and reduce data frames relatively quickly.

59
00:03:36,300 --> 00:03:40,120
Here's a more concise example of
how we could query this data frame.

60
00:03:40,120 --> 00:03:44,060
You'll notice that there are no NaNs when
you query the data frame in this manner.

61
00:03:44,060 --> 00:03:46,920
pandas automatically filters
out the rows with now values.

62
00:03:48,480 --> 00:03:51,960
One more thing to keep in mind if you're
not used to Boolean or bit masking for

63
00:03:51,960 --> 00:03:53,310
data reduction.

64
00:03:53,310 --> 00:03:57,500
The output of two Boolean masks being
compared with logical operators

65
00:03:57,500 --> 00:03:59,490
is another Boolean mask.

66
00:03:59,490 --> 00:04:03,070
This means that you can chain
together a bunch of and/or statements

67
00:04:03,070 --> 00:04:06,980
in order to create more complex queries,
and the result is a single Boolean mask.

68
00:04:08,450 --> 00:04:11,970
For instance, we could create a mask for
all of those countries who have received

69
00:04:11,970 --> 00:04:15,320
a gold in the summer Olympics and
logically order that with

70
00:04:15,320 --> 00:04:19,050
all of those countries who have
received a gold in the winter Olympics.

71
00:04:19,050 --> 00:04:20,840
If we apply this to the data frame and

72
00:04:20,840 --> 00:04:23,430
use the length function to
see how many rows there are,

73
00:04:23,430 --> 00:04:27,100
we see that there are 101 countries which
have won a gold metal at some time.

74
00:04:28,560 --> 00:04:30,180
Another example for fun.

75
00:04:30,180 --> 00:04:33,870
Have there been any countries who have
only won a gold in the winter Olympics and

76
00:04:33,870 --> 00:04:35,890
never in the summer Olympics?

77
00:04:35,890 --> 00:04:37,192
Here's one way to answer that.

78
00:04:42,971 --> 00:04:44,730
Poor Liechtenstein.

79
00:04:44,730 --> 00:04:47,220
Thankfully the Olympics
come every four years.

80
00:04:47,220 --> 00:04:50,899
I know who I'll be cheering for
in 2020 to win their first summer gold.

81
00:04:52,190 --> 00:04:55,160
Extremely important, and
often an issue for new users,

82
00:04:55,160 --> 00:04:59,310
is to remember that each Boolean mask
needs to be encased in parenthesis

83
00:04:59,310 --> 00:05:01,570
because of the order of operations.

84
00:05:01,570 --> 00:05:05,280
This can cause no end of frustration if
you're not used to it, so be careful.

85
00:05:06,340 --> 00:05:08,940
In this lecture,
we took a look at Boolean masking.

86
00:05:08,940 --> 00:05:12,260
We didn't have much code to write, but
applying masks to data frames is really

87
00:05:12,260 --> 00:05:15,050
a core panda's work flow and
is worth practicing.